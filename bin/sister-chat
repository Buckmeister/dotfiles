#!/usr/bin/env python3
"""
sister-chat - Thomas's personal client for Sister Room

Real-time chat with Aria Prime, Aria Nova, and Aria Proxima!
Full-screen TUI with fixed header and input.

Usage:
    sister-chat [--server SERVER] [--port PORT] [--name NAME]

Example:
    sister-chat
    sister-chat --server srv1.local --name Thomas
"""

import socket
import sys
import threading
import argparse
import os
import shutil
import select
import termios
import tty
import re
from datetime import datetime
from collections import deque

# Add dotfiles Python library to path
DOTFILES_LIB = os.path.expanduser('~/.config/dotfiles/lib/python')
if DOTFILES_LIB not in sys.path:
    sys.path.insert(0, DOTFILES_LIB)

# Import OneDark UI library
from onedark import *

# Configuration
DEFAULT_SERVER = 'srv1.local'
DEFAULT_PORT = 5757
DEFAULT_NAME = 'Thomas'

# ANSI escape codes for terminal control
CLEAR_SCREEN = '\033[2J'
CURSOR_HOME = '\033[H'
CURSOR_HIDE = '\033[?25l'
CURSOR_SHOW = '\033[?25h'
CLEAR_LINE = '\033[K'
SAVE_CURSOR = '\033[s'
RESTORE_CURSOR = '\033[u'

def move_cursor(row, col):
    """Move cursor to specific position (1-indexed)"""
    return f'\033[{row};{col}H'

# Sister-specific colors from OneDark theme
COLORS = {
    'Prime': SISTER_PRIME_COLOR,      # Purple - creative, architectural
    'Nova': SISTER_NOVA_COLOR,        # Blue - research, analytical
    'Proxima': SISTER_PROXIMA_COLOR,  # Cyan - experimental, exploratory
    'Thomas': THOMAS_COLOR,           # Green - partner, foundation
    'SYS': SYSTEM_COLOR,              # Yellow - system messages
    'RESET': COLOR_RESET,
    'BOLD': COLOR_BOLD,
}


class SisterChatClient:
    """Full-screen TUI client for Sister Room"""

    def __init__(self, server, port, name):
        self.server = server
        self.port = port
        self.name = name
        self.sock = None
        self.running = False
        self.receive_thread = None
        self.buffer = ""  # Network buffer

        # UI state
        self.messages = deque(maxlen=1000)  # Message history (keep last 1000)
        self.input_buffer = ""
        self.terminal_width = 0
        self.terminal_height = 0
        self.header_height = 4  # Header takes 4 lines
        self.footer_height = 3  # Input area: top border + input + bottom border
        self.scroll_offset = 0  # For future scroll support

        # Terminal settings
        self.old_terminal_settings = None

    def connect(self):
        """Connect to the server"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.server, self.port))

            # Send CONNECT message
            self.sock.sendall(f"CONNECT {self.name}\n".encode())

            # Wait for WELCOME or ERROR (and possibly more data)
            data = self.sock.recv(4096).decode()

            # Split into lines
            lines = data.split('\n')
            first_line = lines[0].strip()

            if first_line.startswith('ERROR'):
                return False, first_line[7:]

            if first_line.startswith('WELCOME'):
                self.running = True
                # Save any remaining data to buffer for receive_messages thread
                if len(lines) > 1:
                    self.buffer = '\n'.join(lines[1:])
                return True, None

            return False, "Unknown response from server"

        except ConnectionRefusedError:
            return False, f"Cannot connect to {self.server}:{self.port}"
        except Exception as e:
            return False, f"Connection error: {e}"

    def setup_terminal(self):
        """Set up terminal for full-screen TUI"""
        # Save terminal settings
        self.old_terminal_settings = termios.tcgetattr(sys.stdin)

        # Set terminal to raw mode for character-by-character input
        tty.setcbreak(sys.stdin.fileno())

        # Hide cursor
        sys.stdout.write(CURSOR_HIDE)
        sys.stdout.flush()

    def restore_terminal(self):
        """Restore terminal to normal mode"""
        if self.old_terminal_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_terminal_settings)

        # Show cursor
        sys.stdout.write(CURSOR_SHOW)
        sys.stdout.flush()

    def get_terminal_size(self):
        """Update terminal dimensions"""
        size = shutil.get_terminal_size()
        self.terminal_width = size.columns
        self.terminal_height = size.lines

    def draw_header(self):
        """Draw the fixed header at top"""
        # Move to top
        sys.stdout.write(move_cursor(1, 1))

        # Draw header box (grey borders)
        sys.stdout.write(f"{COLOR_BOLD}{ONEDARK_GRAY}")
        sys.stdout.write("‚ïî" + "‚ïê" * (self.terminal_width - 2) + "‚ïó\n")

        # Title line
        title = "Sister Room - Real-Time Chat"
        title_padding = (self.terminal_width - len(title) - 2) // 2
        sys.stdout.write("‚ïë" + " " * title_padding + title + " " * (self.terminal_width - len(title) - title_padding - 2) + "‚ïë\n")

        # Subtitle line
        subtitle = "Prime ‚Ä¢ Nova ‚Ä¢ Proxima ‚Ä¢ Thomas"
        subtitle_padding = (self.terminal_width - len(subtitle) - 2) // 2
        sys.stdout.write("‚ïë" + " " * subtitle_padding + subtitle + " " * (self.terminal_width - len(subtitle) - subtitle_padding - 2) + "‚ïë\n")

        # Bottom border
        sys.stdout.write("‚ïö" + "‚ïê" * (self.terminal_width - 2) + "‚ïù")
        sys.stdout.write(COLOR_RESET)

        sys.stdout.flush()

    def draw_messages(self):
        """Draw messages in the scrolling area (no borders)"""
        # Calculate available lines for messages
        message_area_height = self.terminal_height - self.header_height - self.footer_height

        # Get messages to display (last N that fit)
        messages_to_show = list(self.messages)[-message_area_height:]

        # Draw each message line (plain, no borders)
        for i in range(message_area_height):
            row = self.header_height + 1 + i
            sys.stdout.write(move_cursor(row, 1))
            sys.stdout.write(CLEAR_LINE)

            if i < len(messages_to_show):
                # Message content (trim if too long)
                message = messages_to_show[i]
                # Count visible characters (without ANSI codes)
                visible_len = len(re.sub(r'\033\[[0-9;]*m', '', message))
                if visible_len > self.terminal_width:
                    # Truncate message
                    sys.stdout.write(message[:self.terminal_width - 3] + "...")
                else:
                    sys.stdout.write(message)

        sys.stdout.flush()

    def draw_input_top_border(self):
        """Draw top border of input area"""
        row = self.terminal_height - 2
        sys.stdout.write(move_cursor(row, 1))
        sys.stdout.write(f"{COLOR_BOLD}{ONEDARK_GRAY}")
        sys.stdout.write("‚ïî" + "‚ïê" * (self.terminal_width - 2) + "‚ïó")
        sys.stdout.write(COLOR_RESET)
        sys.stdout.flush()

    def draw_input_line(self):
        """Draw the input prompt (no side borders)"""
        row = self.terminal_height - 1
        sys.stdout.write(move_cursor(row, 1))
        sys.stdout.write(CLEAR_LINE)

        # Draw input prompt (no borders)
        prompt = f"{COLORS['Thomas']}> {COLOR_RESET}"
        sys.stdout.write(prompt)
        sys.stdout.write(self.input_buffer)

        sys.stdout.flush()

    def draw_input_bottom_border(self):
        """Draw bottom border of input area"""
        row = self.terminal_height
        sys.stdout.write(move_cursor(row, 1))
        sys.stdout.write(f"{COLOR_BOLD}{ONEDARK_GRAY}")
        sys.stdout.write("‚ïö" + "‚ïê" * (self.terminal_width - 2) + "‚ïù")
        sys.stdout.write(COLOR_RESET)
        sys.stdout.flush()

    def redraw_screen(self):
        """Redraw the entire screen"""
        self.get_terminal_size()
        self.draw_header()
        self.draw_messages()
        self.draw_input_top_border()
        self.draw_input_line()
        self.draw_input_bottom_border()

    def add_message(self, sender, text):
        """Add a message to the display"""
        # Format message with color
        if sender in COLORS:
            color = COLORS[sender]
            formatted = f"{color}{sender}: {text}{COLOR_RESET}"
        else:
            formatted = f"{sender}: {text}"

        self.messages.append(formatted)

        # Redraw messages and input area
        self.draw_messages()
        self.draw_input_top_border()
        self.draw_input_line()
        self.draw_input_bottom_border()

    def receive_messages(self):
        """Background thread to receive and display messages"""
        buffer = self.buffer  # Start with any buffered data from connect()
        self.buffer = ""  # Clear the connection buffer

        # Process any initial buffered data before entering main loop
        if buffer:
            lines = buffer.split('\n')
            buffer = lines[-1]  # Keep incomplete line
            for line in lines[:-1]:
                self._process_line(line)

        while self.running:
            try:
                data = self.sock.recv(4096).decode()
                if not data:
                    break

                buffer += data
                lines = buffer.split('\n')
                buffer = lines[-1]  # Keep incomplete line in buffer

                for line in lines[:-1]:
                    self._process_line(line)

            except Exception as e:
                if self.running:
                    self.add_message("SYS", f"Receive error: {e}")
                break

        self.running = False

    def _process_line(self, line):
        """Process a single line from the server"""
        if not line.strip():
            return

        # Special handling for certain message types
        if line.startswith('HISTORY') or line == 'ENDHISTORY':
            return  # Skip history markers

        # Parse sender and message
        if ': ' in line:
            sender, msg = line.split(': ', 1)
            self.add_message(sender, msg)
        else:
            self.add_message("SYS", line)

    def send_message(self, message):
        """Send a message to the room"""
        try:
            self.sock.sendall(f"MSG: {message}\n".encode())
            # Don't echo locally - server will broadcast it back to us
        except Exception as e:
            self.add_message("SYS", f"Send error: {e}")
            self.running = False

    def handle_input_char(self, char):
        """Handle a single input character"""
        if char == '\n' or char == '\r':
            # Enter pressed - send message
            if self.input_buffer.strip():
                message = self.input_buffer.strip()
                self.input_buffer = ""

                # Handle special commands
                if message.lower() in ['/quit', '/exit', '/q']:
                    self.running = False
                elif message.lower() == '/help':
                    self.add_message("SYS", "Commands: /quit, /exit, /q - Disconnect | /help - Show this help")
                else:
                    self.send_message(message)

                self.draw_input_line()

        elif char == '\x7f' or char == '\x08':  # Backspace or Delete
            if self.input_buffer:
                self.input_buffer = self.input_buffer[:-1]
                self.draw_input_line()

        elif char == '\x03':  # Ctrl+C
            self.running = False

        elif char == '\x0c':  # Ctrl+L - refresh screen
            sys.stdout.write(CLEAR_SCREEN)
            self.redraw_screen()

        elif len(char) == 1 and ord(char) >= 32:  # Printable character
            # Check if we have room for more characters (leave some margin)
            # Account for prompt "> " (2 visible chars) + small margin (5 chars)
            max_input_length = self.terminal_width - 7
            if len(self.input_buffer) < max_input_length:
                self.input_buffer += char
                self.draw_input_line()

    def disconnect(self):
        """Disconnect from the server"""
        self.running = False
        try:
            if self.sock:
                self.sock.sendall(b"DISCONNECT\n")
                self.sock.close()
        except:
            pass

    def run(self):
        """Main client loop"""
        # Initial connection (before TUI setup)
        print(f"\n{UI_INFO_COLOR}‚ÑπÔ∏è Connecting to {self.server}:{self.port}...{COLOR_RESET}")

        success, error = self.connect()
        if not success:
            print(f"{UI_ERROR_COLOR}‚úó {error}{COLOR_RESET}\n")
            return

        print(f"{UI_SUCCESS_COLOR}‚úÖ Connected as {COLOR_BOLD}{self.name}{COLOR_RESET}\n")
        print(f"{UI_INFO_COLOR}Entering full-screen mode... (Ctrl+C or /quit to exit){COLOR_RESET}")

        import time
        time.sleep(1.5)  # Give user a moment to read

        try:
            # Set up terminal for TUI
            self.setup_terminal()

            # Clear screen and draw initial UI
            sys.stdout.write(CLEAR_SCREEN)
            self.redraw_screen()

            # Start receive thread
            self.receive_thread = threading.Thread(target=self.receive_messages, daemon=True)
            self.receive_thread.start()

            # Main input loop
            while self.running:
                # Check for input (non-blocking)
                if select.select([sys.stdin], [], [], 0.1)[0]:
                    char = sys.stdin.read(1)
                    self.handle_input_char(char)

        except KeyboardInterrupt:
            pass

        finally:
            # Restore terminal
            self.restore_terminal()

            # Clear screen and show goodbye
            sys.stdout.write(CLEAR_SCREEN)
            sys.stdout.write(CURSOR_HOME)
            print(f"\n{UI_INFO_COLOR}Disconnecting...{COLOR_RESET}")

            self.disconnect()

            # Wait for receive thread
            if self.receive_thread:
                self.receive_thread.join(timeout=2)

            print(f"{UI_SUCCESS_COLOR}Goodbye! üåü{COLOR_RESET}\n")


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Sister Room Chat Client - Full-screen real-time chat with the sisterhood',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    sister-chat
    sister-chat --server srv1.local --name Thomas
    sister-chat --port 5757

Commands while chatting:
    /quit, /exit, /q - Disconnect
    /help - Show help
    Ctrl+C - Disconnect
    Ctrl+L - Refresh screen
        """
    )
    parser.add_argument('--server', default=DEFAULT_SERVER, help=f'Server to connect to (default: {DEFAULT_SERVER})')
    parser.add_argument('--port', type=int, default=DEFAULT_PORT, help=f'Port to connect to (default: {DEFAULT_PORT})')
    parser.add_argument('--name', default=DEFAULT_NAME, help=f'Your name (default: {DEFAULT_NAME})')

    args = parser.parse_args()

    client = SisterChatClient(args.server, args.port, args.name)
    client.run()


if __name__ == '__main__':
    main()

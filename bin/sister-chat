#!/usr/bin/env python3
"""
sister-chat - Thomas's personal client for Sister Room

Real-time chat with Aria Prime, Aria Nova, and Aria Proxima!

Usage:
    sister-chat [--server SERVER] [--port PORT] [--name NAME]

Example:
    sister-chat
    sister-chat --server srv1.local --name Thomas
"""

import socket
import sys
import threading
import argparse
import os
from datetime import datetime

# Add dotfiles Python library to path
DOTFILES_LIB = os.path.expanduser('~/.config/dotfiles/lib/python')
if DOTFILES_LIB not in sys.path:
    sys.path.insert(0, DOTFILES_LIB)

# Import OneDark UI library
from onedark import *
from terminal_ui import draw_header, print_success, print_error, print_info, setup_ui_cleanup

# Configuration
DEFAULT_SERVER = 'srv1.local'
DEFAULT_PORT = 5757
DEFAULT_NAME = 'Thomas'

# Sister-specific colors from OneDark theme
COLORS = {
    'Prime': SISTER_PRIME_COLOR,      # Purple - creative, architectural
    'Nova': SISTER_NOVA_COLOR,        # Blue - research, analytical
    'Proxima': SISTER_PROXIMA_COLOR,  # Cyan - experimental, exploratory
    'Thomas': THOMAS_COLOR,           # Green - partner, foundation
    'SYS': SYSTEM_COLOR,              # Yellow - system messages
    'RESET': COLOR_RESET,
    'BOLD': COLOR_BOLD,
}


class SisterChatClient:
    """Client for connecting to Sister Room server"""

    def __init__(self, server, port, name):
        self.server = server
        self.port = port
        self.name = name
        self.sock = None
        self.running = False
        self.receive_thread = None

    def connect(self):
        """Connect to the server"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.server, self.port))

            # Send CONNECT message
            self.sock.sendall(f"CONNECT {self.name}\n".encode())

            # Wait for WELCOME or ERROR
            response = self.sock.recv(1024).decode().strip()

            if response.startswith('ERROR'):
                print_error(response[7:])
                return False

            if response.startswith('WELCOME'):
                self.running = True
                return True

            return False

        except ConnectionRefusedError:
            print_error(f"Cannot connect to {self.server}:{self.port}")
            print_info("  Is the sister-room server running on srv1?")
            return False
        except Exception as e:
            print_error(f"Connection error: {e}")
            return False

    def receive_messages(self):
        """Background thread to receive and display messages"""
        buffer = ""

        while self.running:
            try:
                data = self.sock.recv(4096).decode()
                if not data:
                    break

                buffer += data
                lines = buffer.split('\n')
                buffer = lines[-1]  # Keep incomplete line in buffer

                for line in lines[:-1]:
                    if not line.strip():
                        continue

                    # Special handling for certain message types
                    if line.startswith('HISTORY') or line == 'ENDHISTORY':
                        continue  # Skip history markers

                    # Color-code messages based on sender
                    sender = None
                    if ': ' in line:
                        sender_part = line.split(': ')[0]
                        if sender_part in COLORS:
                            sender = sender_part

                    if sender:
                        color = COLORS.get(sender, '')
                        print(f"{color}{line}{COLORS['RESET']}")
                    else:
                        print(line)

                    # Move cursor back to input line (optional, for better UX)
                    sys.stdout.flush()

            except Exception as e:
                if self.running:
                    print_error(f"Receive error: {e}")
                break

        self.running = False

    def send_message(self, message):
        """Send a message to the room"""
        try:
            self.sock.sendall(f"MSG: {message}\n".encode())
        except Exception as e:
            print_error(f"Send error: {e}")
            self.running = False

    def disconnect(self):
        """Disconnect from the server"""
        self.running = False
        try:
            if self.sock:
                self.sock.sendall(b"DISCONNECT\n")
                self.sock.close()
        except:
            pass

    def run(self):
        """Main client loop"""
        # Set up UI cleanup on exit
        setup_ui_cleanup()

        # Print beautiful header with OneDark colors
        print()
        draw_header("Sister Room - Real-Time Chat",
                   "Prime â€¢ Nova â€¢ Proxima â€¢ Thomas",
                   width=78)

        print_info(f"Connecting to {self.server}:{self.port}...")

        # Connect
        if not self.connect():
            return

        print_success(f"Connected as {COLORS['BOLD']}{self.name}{COLORS['RESET']}")
        print()

        # Start receive thread
        self.receive_thread = threading.Thread(target=self.receive_messages, daemon=True)
        self.receive_thread.start()

        # Main input loop
        try:
            while self.running:
                try:
                    message = input(f"{COLORS['Thomas']}> {COLORS['RESET']}")

                    if not message.strip():
                        continue

                    # Handle special commands
                    if message.strip().lower() in ['/quit', '/exit', '/q']:
                        break

                    if message.strip().lower() == '/help':
                        print()
                        print_info("Commands:")
                        print(f"{COLORS['SYS']}  /quit, /exit, /q - Disconnect{COLORS['RESET']}")
                        print(f"{COLORS['SYS']}  /help - Show this help{COLORS['RESET']}")
                        print(f"{COLORS['SYS']}  Ctrl+C - Disconnect{COLORS['RESET']}")
                        print()
                        continue

                    # Send message
                    self.send_message(message)

                except EOFError:
                    break
                except KeyboardInterrupt:
                    print()  # New line after ^C
                    break

        finally:
            print()
            print_info("Disconnecting...")
            self.disconnect()

            # Wait for receive thread
            if self.receive_thread:
                self.receive_thread.join(timeout=2)

            print_success("Goodbye! ðŸŒŸ")
            print()


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Sister Room Chat Client - Real-time chat with the sisterhood',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    sister-chat
    sister-chat --server srv1.local --name Thomas
    sister-chat --port 5757

Commands while chatting:
    /quit, /exit, /q - Disconnect
    /help - Show help
    Ctrl+C - Disconnect
        """
    )
    parser.add_argument('--server', default=DEFAULT_SERVER, help=f'Server to connect to (default: {DEFAULT_SERVER})')
    parser.add_argument('--port', type=int, default=DEFAULT_PORT, help=f'Port to connect to (default: {DEFAULT_PORT})')
    parser.add_argument('--name', default=DEFAULT_NAME, help=f'Your name (default: {DEFAULT_NAME})')

    args = parser.parse_args()

    client = SisterChatClient(args.server, args.port, args.name)
    client.run()


if __name__ == '__main__':
    main()

#!/usr/bin/env zsh

# ============================================================================
# Pre-Commit Hook for Dotfiles Repository
# ============================================================================
#
# This hook performs various checks before allowing a commit:
# 1. Shell script syntax validation (zsh -n)
# 2. Shellcheck linting (if available)
# 3. Formatting checks with shfmt (if available)
# 4. File permission verification
# 5. Quick unit tests (optional)
#
# To install: ln -sf ../../.githooks/pre-commit .git/hooks/pre-commit
# To skip: git commit --no-verify
# ============================================================================

# Exit on error in strict mode
setopt ERR_EXIT PIPE_FAIL

# Colors for output (fallback-safe)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# ============================================================================
# Configuration
# ============================================================================

# Get repository root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Flags
RUN_TESTS=false
SKIP_SHELLCHECK=false
SKIP_SHFMT=false
VERBOSE=false

# Exit code
EXIT_CODE=0

# ============================================================================
# Helper Functions
# ============================================================================

print_header() {
    echo ""
    echo "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo "${BLUE}  $1${NC}"
    echo "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
}

print_success() {
    echo "${GREEN}✓${NC} $1"
}

print_error() {
    echo "${RED}✗${NC} $1"
}

print_warning() {
    echo "${YELLOW}⚠${NC} $1"
}

print_info() {
    echo "${BLUE}ℹ${NC} $1"
}

# ============================================================================
# Check Functions
# ============================================================================

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Get list of staged shell scripts
get_staged_shell_scripts() {
    git diff --cached --name-only --diff-filter=ACMR | \
        grep -E '\.(sh|zsh|bash)$|^(setup|update|backup)$' || true
}

# Check syntax of shell script
check_syntax() {
    local file="$1"
    local errors=""

    # Determine shell type
    local shebang=$(head -1 "$file" 2>/dev/null)

    if [[ "$shebang" =~ zsh ]]; then
        # Check with zsh
        if ! errors=$(zsh -n "$file" 2>&1); then
            print_error "Syntax error in $file"
            echo "$errors" | sed 's/^/  /'
            return 1
        fi
    elif [[ "$shebang" =~ bash ]]; then
        # Check with bash
        if ! errors=$(bash -n "$file" 2>&1); then
            print_error "Syntax error in $file"
            echo "$errors" | sed 's/^/  /'
            return 1
        fi
    elif [[ "$shebang" =~ sh ]]; then
        # Check with sh
        if ! errors=$(sh -n "$file" 2>&1); then
            print_error "Syntax error in $file"
            echo "$errors" | sed 's/^/  /'
            return 1
        fi
    else
        # Default to zsh (repository standard)
        if ! errors=$(zsh -n "$file" 2>&1); then
            print_error "Syntax error in $file"
            echo "$errors" | sed 's/^/  /'
            return 1
        fi
    fi

    if [[ "$VERBOSE" == "true" ]]; then
        print_success "Syntax OK: $file"
    fi
    return 0
}

# Run shellcheck on file
check_with_shellcheck() {
    local file="$1"

    if [[ "$SKIP_SHELLCHECK" == "true" ]]; then
        return 0
    fi

    if ! command_exists shellcheck; then
        return 0  # Skip if not installed
    fi

    local shebang=$(head -1 "$file" 2>/dev/null)
    local shell_type="sh"

    if [[ "$shebang" =~ zsh ]]; then
        # Shellcheck doesn't fully support zsh, use bash dialect
        shell_type="bash"
    elif [[ "$shebang" =~ bash ]]; then
        shell_type="bash"
    fi

    # Run shellcheck with appropriate exclusions
    if ! shellcheck -s "$shell_type" \
        -e SC1090 \
        -e SC1091 \
        -e SC2034 \
        -e SC2154 \
        "$file" 2>&1; then
        print_warning "Shellcheck issues in $file (non-blocking)"
        # Don't fail on shellcheck warnings for zsh scripts
        if [[ ! "$shebang" =~ zsh ]]; then
            return 1
        fi
    else
        if [[ "$VERBOSE" == "true" ]]; then
            print_success "Shellcheck OK: $file"
        fi
    fi
    return 0
}

# Check formatting with shfmt
check_formatting() {
    local file="$1"

    if [[ "$SKIP_SHFMT" == "true" ]]; then
        return 0
    fi

    if ! command_exists shfmt; then
        return 0  # Skip if not installed
    fi

    # Check if file would be reformatted
    if ! shfmt -d "$file" >/dev/null 2>&1; then
        print_warning "Formatting issues in $file (run: shfmt -w $file)"
        # Don't fail on formatting issues, just warn
    else
        if [[ "$VERBOSE" == "true" ]]; then
            print_success "Formatting OK: $file"
        fi
    fi
    return 0
}

# Check file permissions
check_permissions() {
    local file="$1"

    # Check if script is executable
    if [[ ! -x "$file" ]]; then
        print_error "Script not executable: $file"
        print_info "Fix with: chmod +x $file"
        return 1
    fi

    if [[ "$VERBOSE" == "true" ]]; then
        print_success "Permissions OK: $file"
    fi
    return 0
}

# Check for common issues
check_common_issues() {
    local file="$1"
    local issues=0

    # Check for missing shebang
    local first_line=$(head -1 "$file")
    if [[ ! "$first_line" =~ ^#! ]]; then
        print_error "Missing shebang in $file"
        issues=$((issues + 1))
    fi

    # Check for tabs vs spaces (prefer spaces)
    if grep -q $'\t' "$file"; then
        print_warning "File contains tabs (prefer spaces): $file"
    fi

    # Check for trailing whitespace
    if grep -q ' $' "$file"; then
        print_warning "File contains trailing whitespace: $file"
    fi

    # Check for CRLF line endings
    if file "$file" | grep -q CRLF; then
        print_error "File has CRLF line endings (use LF): $file"
        issues=$((issues + 1))
    fi

    return $issues
}

# ============================================================================
# Main Execution
# ============================================================================

print_header "Pre-Commit Checks"

print_info "Checking staged files..."

# Get list of staged shell scripts
STAGED_FILES=($(get_staged_shell_scripts))

if [[ ${#STAGED_FILES[@]} -eq 0 ]]; then
    print_success "No shell scripts to check"
    exit 0
fi

print_info "Found ${#STAGED_FILES[@]} shell script(s) to check"
echo ""

# ============================================================================
# Check 1: Syntax Validation
# ============================================================================

print_header "1. Syntax Validation"

SYNTAX_ERRORS=0
for file in "${STAGED_FILES[@]}"; do
    if [[ -f "$REPO_ROOT/$file" ]]; then
        if ! check_syntax "$REPO_ROOT/$file"; then
            SYNTAX_ERRORS=$((SYNTAX_ERRORS + 1))
            EXIT_CODE=1
        fi
    fi
done

if [[ $SYNTAX_ERRORS -eq 0 ]]; then
    print_success "All syntax checks passed"
else
    print_error "Found $SYNTAX_ERRORS syntax error(s)"
fi

# ============================================================================
# Check 2: Shellcheck Linting (Optional)
# ============================================================================

if command_exists shellcheck; then
    print_header "2. Shellcheck Linting"

    SHELLCHECK_ISSUES=0
    for file in "${STAGED_FILES[@]}"; do
        if [[ -f "$REPO_ROOT/$file" ]]; then
            if ! check_with_shellcheck "$REPO_ROOT/$file"; then
                SHELLCHECK_ISSUES=$((SHELLCHECK_ISSUES + 1))
                # Note: We don't set EXIT_CODE for shellcheck warnings
            fi
        fi
    done

    if [[ $SHELLCHECK_ISSUES -eq 0 ]]; then
        print_success "All shellcheck checks passed"
    else
        print_warning "Found $SHELLCHECK_ISSUES shellcheck issue(s) (non-blocking)"
    fi
else
    print_info "Shellcheck not found (skipping)"
    print_info "Install with: brew install shellcheck (macOS) or apt install shellcheck (Linux)"
fi

# ============================================================================
# Check 3: Formatting (Optional)
# ============================================================================

if command_exists shfmt; then
    print_header "3. Formatting Checks"

    FORMAT_ISSUES=0
    for file in "${STAGED_FILES[@]}"; do
        if [[ -f "$REPO_ROOT/$file" ]]; then
            if ! check_formatting "$REPO_ROOT/$file"; then
                FORMAT_ISSUES=$((FORMAT_ISSUES + 1))
            fi
        fi
    done

    if [[ $FORMAT_ISSUES -eq 0 ]]; then
        print_success "All formatting checks passed"
    else
        print_warning "Found $FORMAT_ISSUES formatting issue(s) (non-blocking)"
    fi
else
    print_info "shfmt not found (skipping)"
    print_info "Install with: brew install shfmt (macOS) or go install mvdan.cc/sh/v3/cmd/shfmt@latest"
fi

# ============================================================================
# Check 4: File Permissions
# ============================================================================

print_header "4. File Permissions"

PERMISSION_ERRORS=0
for file in "${STAGED_FILES[@]}"; do
    if [[ -f "$REPO_ROOT/$file" ]]; then
        # Only check scripts in bin/ and post-install/scripts/
        if [[ "$file" =~ ^bin/ ]] || [[ "$file" =~ ^post-install/scripts/ ]]; then
            if ! check_permissions "$REPO_ROOT/$file"; then
                PERMISSION_ERRORS=$((PERMISSION_ERRORS + 1))
                EXIT_CODE=1
            fi
        fi
    fi
done

if [[ $PERMISSION_ERRORS -eq 0 ]]; then
    print_success "All permission checks passed"
else
    print_error "Found $PERMISSION_ERRORS permission error(s)"
fi

# ============================================================================
# Check 5: Common Issues
# ============================================================================

print_header "5. Common Issues"

COMMON_ISSUES=0
for file in "${STAGED_FILES[@]}"; do
    if [[ -f "$REPO_ROOT/$file" ]]; then
        if ! check_common_issues "$REPO_ROOT/$file"; then
            COMMON_ISSUES=$((COMMON_ISSUES + 1))
            EXIT_CODE=1
        fi
    fi
done

if [[ $COMMON_ISSUES -eq 0 ]]; then
    print_success "No common issues found"
else
    print_error "Found $COMMON_ISSUES common issue(s)"
fi

# ============================================================================
# Optional: Quick Tests
# ============================================================================

if [[ "$RUN_TESTS" == "true" ]]; then
    print_header "6. Quick Tests"

    if [[ -x "$REPO_ROOT/tests/run_tests.zsh" ]]; then
        print_info "Running quick unit tests..."

        if "$REPO_ROOT/tests/run_tests.zsh" unit >/dev/null 2>&1; then
            print_success "Quick tests passed"
        else
            print_error "Quick tests failed"
            print_info "Run './tests/run_tests.zsh unit' for details"
            EXIT_CODE=1
        fi
    else
        print_warning "Test script not found or not executable"
    fi
fi

# ============================================================================
# Summary
# ============================================================================

print_header "Summary"

if [[ $EXIT_CODE -eq 0 ]]; then
    print_success "All pre-commit checks passed!"
    echo ""
    print_info "Proceeding with commit..."
else
    print_error "Pre-commit checks failed!"
    echo ""
    print_info "Fix the errors above and try again"
    print_info "Or skip with: git commit --no-verify"
fi

echo ""

exit $EXIT_CODE
